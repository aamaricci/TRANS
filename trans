#!/usr/bin/perl
use File::Basename;
use File::Temp;
use Archive::Extract;
use Math::Trig;			# includes trigonometric functions
use Math::Complex;		# includes support for complex


#SETUP OF SOME GLOBAL VARIABLES USED IN THE REST OF THE SCRIPT
$home = $ENV{HOME};
$login=getpwuid($<);



sub get_temp_filename {
  my $template=$_[0];
  my $fh = File::Temp->new(
      TEMPLATE => "$template".'.XXXXX',
      DIR => "/tmp",
      );
  $tmp_files[++$#tmp_files]=$fh->filename;
  return $fh->filename;
}

# RETURN TRUE IF THE PASSED FILE CONTAINS MORE THAN ONE BLOCK SEPARATED
# BY EITHER SPACE, TABS OR BLANK LINES
sub count_mblock{		
  my $file=$_[0];		
  $count_blocks=0;
  open(FILE, "< $file") or die "can't open $file: $!";
  $lnew="\n";
  foreach (<FILE>) {
    $lold=$lnew;
    $lnew=$_;
    if ( $lold =~ /^\s*$/ && !($lnew =~ /^\s*$/)) {
      $count_blocks++;
    }
  }
  close(FILE);
  undef $var;
  if ($count_blocks>1) {$var=$count_blocks;}
  return $var;
}



sub scatter_mblock{
  my $file = $_[0];
  my @ftmp_list;
  my $count_blanks=0;
  my $fcount=0;
  open(FIN, "$file") or die "can't open $file: $!";
  my $lnew="\n";
  foreach (<FIN>) {
    my $lold=$lnew;
    $lnew=$_;
    if ( $lold =~ /^\s*$/ && !($lnew =~ /^\s*$/)){	# if lold is empty open a new tmp file
      $fcount++;
      my $filename = basename($file);
      my $tmpfile  = get_temp_filename($filename.'.set.'.$fcount);
      $ftmp_list[++$#ftmp_list] = $tmpfile;
      open(FOUT, "> $tmpfile");
    }
    print FOUT $lnew;
    if ( $lnew =~ /^\s*$/) {
      close(FOUT);
    }				# if lnew is empty close tmp file
  }
  close(FIN);
  my $tmpfile=$ftmp_list[$#ftmp_list];
  open(FOUT, ">> $tmpfile");
  print FOUT "\n";
  close(FOUT);
  return @ftmp_list;
}



$i=0;
foreach $f (@ARGV) {  
  my ($dir, $name, $ext) = fileparse($f, ".gz");
  if ($ext eq ".gz") {
    $i++;
    my $tmp = get_temp_filename('trans_gzip.'.$login);
    my $ae = Archive::Extract->new( archive => $f );
    my $ok = $ae->extract( to => $tmp );
    die $ae->error unless $ok;
    $ARGV[$#ARGV + 1] = $tmp;
    s/^$f$// for @ARGV;
  }
}



push @files, "<&STDIN" unless -t STDIN; # stdin is treated like any other file
foreach (@ARGV){
  if (-e "$_"){	    # if file exists, it mush be function name
    undef @bfiles;
    undef $iblock;
    $iblock=count_mblock($_);
    if ($iblock) {
      @bfiles=scatter_mblock($_);
      print STDERR "scatter $_ into blocks @bfiles\n";
      push @files, @bfiles;
    }else{
      push @files, $_;
    }
  } else{
    if (substr($_,0,1) eq '-'){
      push @options, $_;
    }else{
      push @trans, $_;     # otherwise it is an expression for trans
    }
  }
}


foreach (@files) {
  open $_, $_;
} # All files being transformed are opened


$key='#';

foreach (@options){
  
  if ($_ eq "-h" or $_ eq "--help" or $_ eq "info") {
    print "**************** TRANS *******************\n";
    print "**      transform data files             **\n";
    print "** Copyright        Kristjan Haule       **\n";
    print "** Version 2.1            22.9.2011      **\n";
    print "** modified  by Adriano Amaricci 2013-15  **\n";
    print "******************************************\n";
    print "\n";
    print " trans [options] [file/stdin]\n";
    print "\n";
    print "Options:   -k=C; --key=C [default=\#, allowed=\#,\%,\$,_,\@]\n";
    print "\n";
    print "Usage: \n";
    print " [... |] trans f1(C1, C2, ...), [f2(C1, C2, ...)] [file1 file2 ...]\n";
    print "\n";
    print " cat file | trans C1 C3-C2 \'tan(C4)\'\n";
    print "\n";
    print " trans C1, C2-C1, C3/C1 file1\n";
    print "\n";
    print "note: check your shell passes special characters to trans!\n";
    print "      characters like \\,\$,\# need a double-quote or preceding slash!!\n";
    print "\n";
    exit;
  }
  
  #--------------------------------------------------------------------
  if (substr($_,0,3) eq "-k=") {
    $key=substr($_,3);
    next;
  }
  if (substr($_,0,6) eq "--key=") {
    $key=substr($_,6);
    next;
  }

  if (substr($_,0,3) eq "-wl" or substr($_,0,11) eq "--with-line" or substr($_,0,2) eq "-b") {
    $with_line_indx=1;
    next;
  }

  if (substr($_,0,3) eq "-l=") {
    $w_selected_line=1;
    $selected_line=substr($_,3);
    next;
  }
  if (substr($_,0,7) eq "--line=") {
    $w_selected_line=1;
    $selected_line=substr($_,7);
    next;
  }
}

if (! grep { $key eq $_ } qw{# $ % ^ _ @ ~}){
  die("key is not allowed. try: [#, $, %, ^, _, @, ~] \n" );
}



foreach ($j=0;$j<=$#files;$j++) {  
  foreach (@trans) {
    if (index($_,':') eq -1) {
      my $opt=$_;
      $opt =~ s/$key//g;
      push @new_trans, "$key".($j+1).":"."$opt";
    }
  } 
}
foreach (@trans) {
  if ( index($_,':') > -1) {
    push @new_trans, $_
  }
}

@trans  = @new_trans;
@trans_ = @trans;

print "\@trans = @trans\n";

foreach (@trans){
  # in any user defined rule, it replaces symbol $KEY by spl in the following way:
  # KEY2:3  ->  $spl[1][2]
  # KEY3    ->  $spl[0][3]
  s/$key(\d+):(\d+)/\$spl\[${\($1-1)}\]\[${\($2-1)}\]/g;
  s/$key(\d+)/\$spl\[0\]\[${\($1-1)}\]/g;
}

print "\@trans = @trans\n";

@{$spl[0]} = (' ');		# object spl is initialized


# Main loop
$line_indx=0;
$lline='';
$legend=1;
LB: while (defined($spl[0][0])){ # goes over all lines:

  $line_indx++;
  $fline='';
  
  #goes over all files and store the actual lines into $spl[i][j], so that this object contains the j-th column of the i-th file.
  $i=0;  
  foreach $f (@files) {
    $_ = <$f>;
    if ($_ =~ /^\s*#/) {
      next;
    }				# skip line if it contains #
    @{$spl[$i++]} = split(' ',$_);
    if (not defined($spl[0][0])) { # if first column does not exist, we reached end-of-file: exit
      last LB;
    }
  }
  

  #now process each column using the fact that options in @trans have been transformed into string 
  #matching the name of the 2D array spl[][] storing the numbers for this line:
  #eval peforms the operations specified in @trans.
  #len_var stores the lenght of the number to produce the trans.info legend
  #line glue the value together
  $line = "";
  $jj=0;
  foreach $col (@trans) {
    $val = eval $col;
    $len_var[$jj++]=length $val;
    $line .= $val . "\t";
  }
    
  if ($legend) {
    if (not $lline eq "") {
      $lline.="\t";
    }
    if ($with_line_indx) {
      $lline.="I\t";
    }
    $lline .= "F".$i.":";
    $jj=0;
    foreach $col (@trans_) {
      $string ="%-" . ($len_var[$jj++]+1) . 's';	
      $lline .= sprintf("$string",$col)."\t";
    }
  }
    
  if ($with_line_indx) {
    $fline.="$line_indx\t"."$line"."\t";
  } else {
    $fline.="$line"."\t";
  }
  
  if ($legend) {
    open(FILE,">trans.info");
    print FILE "$lline\n";
    close(FILE);
    undef $legend;
  }
  
  if (not $w_selected_line) {
    print "$fline\n";
  } else {
    if ($line_indx eq $selected_line) {
      print "$fline\n";
      last LB;
    }
  }  
}
  


sub real{ return Re(@_[0]);}
sub imag{ return Im(@_[0]);}
sub cmplx{ return @_[0]+i*@_[1];}
sub fermi{ return 1.0/(exp(@_[0])+1);}
sub nbose{ return 1.0/(exp(@_[0])-1);}
sub pow2{ return @_[0]*@_[0];}
sub sign{return @_[0]>=0 ? 1 : -1;}
sub Hbethe{
    my $ceta = @_[0];
    return -0.5*(Im($ceta)-sign(Re($ceta))*sign(Im($ceta))*Im(sqrt($ceta**2-4.)))/pi;
}
sub HBethe{
    my $ceta = @_[0];
    return -2*(Im($ceta)-sign(Re($ceta))*sign(Im($ceta))*Im(sqrt($ceta**2-1.)))/pi;
}

